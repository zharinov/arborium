<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arborium Host Demo</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 {
      color: #00d4ff;
    }
    .subtitle {
      color: #888;
      margin-bottom: 20px;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    .panel {
      background: #16213e;
      border-radius: 8px;
      padding: 16px;
    }
    .panel h2 {
      margin-top: 0;
      color: #00d4ff;
      font-size: 16px;
    }
    textarea {
      width: 100%;
      height: 300px;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 14px;
      background: #0f0f23;
      color: #eee;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 12px;
      resize: vertical;
    }
    select {
      padding: 8px 12px;
      font-size: 14px;
      background: #0f0f23;
      color: #eee;
      border: 1px solid #333;
      border-radius: 4px;
      margin-bottom: 12px;
    }
    button {
      padding: 8px 16px;
      font-size: 14px;
      background: #00d4ff;
      color: #1a1a2e;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 8px;
    }
    button:hover {
      background: #00b8e6;
    }
    button:disabled {
      background: #555;
      cursor: not-allowed;
    }
    .output {
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 12px;
      white-space: pre-wrap;
      background: #0f0f23;
      padding: 12px;
      border-radius: 4px;
      max-height: 400px;
      overflow: auto;
    }
    .highlighted {
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 14px;
      line-height: 1.5;
      background: #0f0f23;
      padding: 12px;
      border-radius: 4px;
      white-space: pre-wrap;
      overflow: auto;
    }
    .status {
      color: #888;
      font-size: 12px;
      margin-top: 8px;
    }
    .status.loading { color: #ffaa00; }
    .status.ready { color: #00ff88; }
    .status.error { color: #ff4444; }

    /* Syntax highlighting colors */
    .keyword { color: #c678dd; }
    .function { color: #61afef; }
    .function-method { color: #61afef; }
    .function-macro { color: #e5c07b; }
    .string { color: #98c379; }
    .number { color: #d19a66; }
    .constant { color: #d19a66; }
    .comment { color: #5c6370; font-style: italic; }
    .type { color: #e5c07b; }
    .variable { color: #e06c75; }
    .variable-builtin { color: #e5c07b; }
    .property { color: #abb2bf; }
    .operator { color: #56b6c2; }
    .punctuation-bracket { color: #abb2bf; }
    .punctuation-delimiter { color: #abb2bf; }
    .tag { color: #e06c75; }
    .attribute { color: #d19a66; }
    .label { color: #61afef; }
    .module { color: #e5c07b; }
    .namespace { color: #e5c07b; }
    .constructor { color: #e5c07b; }
    .embedded { background: rgba(97, 175, 239, 0.1); }
  </style>
</head>
<body>
  <h1>ðŸŒ³ Arborium Host Component Demo</h1>
  <p class="subtitle">
    This demo uses a WASM <strong>host component</strong> that orchestrates grammar plugins.
    The host manages documents and resolves language injections automatically.
  </p>

  <div class="container">
    <div class="panel">
      <h2>Input</h2>
      <select id="language">
        <option value="rust">Rust</option>
        <option value="javascript">JavaScript</option>
        <option value="html" selected>HTML (with JS injection)</option>
      </select>
      <button id="parse">Highlight</button>
      <textarea id="input"></textarea>
      <div id="status" class="status">Loading host component...</div>
    </div>

    <div class="panel">
      <h2>Highlighted Output</h2>
      <div id="highlighted" class="highlighted"></div>
    </div>
  </div>

  <div class="panel" style="margin-top: 20px;">
    <h2>Host Component Info</h2>
    <div id="output" class="output">Waiting for initialization...</div>
  </div>

  <script type="module">
    // State
    const statusEl = document.getElementById('status');
    const outputEl = document.getElementById('output');
    const highlightedEl = document.getElementById('highlighted');

    const pluginsUrl = '../dist/plugins';

    // Maps plugin handle -> plugin module
    const loadedPlugins = new Map();
    // Maps session handle -> {plugin, session}
    const sessions = new Map();

    let nextPluginHandle = 1;
    let nextSessionHandle = 1;

    // WASI stubs for browser (used by both host and plugins)
    // Include both versioned and unversioned keys since jco may use either
    const environmentStub = { getEnvironment() { return []; } };
    const exitStub = { exit(status) { if (status && status.tag === 'err') throw new Error('WASI exit'); } };
    const stderrStub = {
      getStderr() {
        return {
          blockingWriteAndFlush() {},
          write() { return { tag: 'ok', val: 0n }; },
          checkWrite() { return { tag: 'ok', val: 0n }; },
          blockingFlush() {},
        };
      },
    };
    const stdinStub = { getStdin() { return { read() { return { tag: 'ok', val: new Uint8Array() }; } }; } };
    const stdoutStub = {
      getStdout() {
        return {
          blockingWriteAndFlush() {},
          write() { return { tag: 'ok', val: 0n }; },
          checkWrite() { return { tag: 'ok', val: 0n }; },
          blockingFlush() {},
        };
      },
    };
    const wallClockStub = { now() { return { seconds: BigInt(Math.floor(Date.now() / 1000)), nanoseconds: 0 }; } };
    const preopensStub = { getDirectories() { return []; } };
    const filesystemTypesStub = { filesystemErrorCode() { return undefined; } };
    const errorStub = {};
    const streamsStub = {};
    const randomSeedStub = { insecureSeed() { return [BigInt(Date.now()), BigInt(Math.floor(Math.random() * 0xFFFFFFFF))]; } };

    const wasiStubs = {
      // Versioned keys
      'wasi:cli/environment@0.2.3': environmentStub,
      'wasi:cli/exit@0.2.3': exitStub,
      'wasi:cli/stderr@0.2.3': stderrStub,
      'wasi:cli/stdin@0.2.3': stdinStub,
      'wasi:cli/stdout@0.2.3': stdoutStub,
      'wasi:clocks/wall-clock@0.2.3': wallClockStub,
      'wasi:filesystem/preopens@0.2.3': preopensStub,
      'wasi:filesystem/preopens@0.2.2': preopensStub,
      'wasi:filesystem/types@0.2.3': filesystemTypesStub,
      'wasi:io/error@0.2.3': errorStub,
      'wasi:io/streams@0.2.3': streamsStub,
      'wasi:random/insecure-seed': randomSeedStub,
      // Unversioned keys (for jco compatibility)
      'wasi:cli/environment': environmentStub,
      'wasi:cli/exit': exitStub,
      'wasi:cli/stderr': stderrStub,
      'wasi:cli/stdin': stdinStub,
      'wasi:cli/stdout': stdoutStub,
      'wasi:clocks/wall-clock': wallClockStub,
      'wasi:filesystem/preopens': preopensStub,
      'wasi:filesystem/types': filesystemTypesStub,
      'wasi:io/error': errorStub,
      'wasi:io/streams': streamsStub,
    };

    // Plugin cache (by language name)
    const pluginModules = new Map();
    // Cache for compiled WASM modules (shared shims get reused)
    const compiledModules = new Map();

    async function loadPluginModule(lang) {
      if (pluginModules.has(lang)) return pluginModules.get(lang);

      statusEl.className = 'status loading';
      statusEl.textContent = `Loading ${lang} plugin...`;

      const pluginUrl = `${pluginsUrl}/${lang}/grammar.js`;
      const { instantiate } = await import(pluginUrl);

      const getCoreModule = async (path) => {
        // Resolve the path relative to the plugin directory
        // path can be 'grammar_bg.wasm' or '../shared/shim.core2.wasm'
        let url;
        if (path.startsWith('../')) {
          // Shared module - resolve relative to plugins dir
          url = `${pluginsUrl}/${path}`;
        } else {
          url = `${pluginsUrl}/${lang}/${path}`;
        }

        // Check cache first (important for shared modules!)
        if (compiledModules.has(url)) {
          return compiledModules.get(url);
        }

        const response = await fetch(url);
        const bytes = await response.arrayBuffer();
        const module = await WebAssembly.compile(bytes);
        compiledModules.set(url, module);
        return module;
      };

      const component = await instantiate(getCoreModule, wasiStubs);
      pluginModules.set(lang, component.plugin);
      return component.plugin;
    }

    // Plugin provider interface - these functions are called by the host WASM
    const pluginProvider = {
      loadPlugin(language) {
        // Note: This needs to be synchronous from the host's perspective
        // but we've already preloaded plugins, so this should work
        const plugin = pluginModules.get(language);
        if (!plugin) {
          console.warn(`Plugin not preloaded: ${language}`);
          return undefined;
        }

        const handle = nextPluginHandle++;
        loadedPlugins.set(handle, { plugin, language });
        console.log(`[plugin-provider] loadPlugin(${language}) -> handle ${handle}`);
        return handle;
      },

      getInjectionLanguages(pluginHandle) {
        const info = loadedPlugins.get(pluginHandle);
        if (!info) return [];
        const langs = info.plugin.injectionLanguages();
        console.log(`[plugin-provider] getInjectionLanguages(${pluginHandle}) -> [${langs.join(', ')}]`);
        return langs;
      },

      createPluginSession(pluginHandle) {
        const info = loadedPlugins.get(pluginHandle);
        if (!info) throw new Error(`Invalid plugin handle: ${pluginHandle}`);

        const session = info.plugin.createSession();
        const handle = nextSessionHandle++;
        sessions.set(handle, { pluginHandle, session });
        console.log(`[plugin-provider] createPluginSession(${pluginHandle}) -> session ${handle}`);
        return handle;
      },

      freePluginSession(pluginHandle, sessionHandle) {
        const sessionInfo = sessions.get(sessionHandle);
        if (!sessionInfo) return;

        const pluginInfo = loadedPlugins.get(pluginHandle);
        if (pluginInfo) {
          pluginInfo.plugin.freeSession(sessionInfo.session);
        }
        sessions.delete(sessionHandle);
        console.log(`[plugin-provider] freePluginSession(${pluginHandle}, ${sessionHandle})`);
      },

      pluginSetText(pluginHandle, sessionHandle, text) {
        const sessionInfo = sessions.get(sessionHandle);
        const pluginInfo = loadedPlugins.get(pluginHandle);
        if (!sessionInfo || !pluginInfo) return;

        pluginInfo.plugin.setText(sessionInfo.session, text);
        console.log(`[plugin-provider] pluginSetText(${pluginHandle}, ${sessionHandle}, "${text.slice(0, 30)}...")`);
      },

      pluginApplyEdit(pluginHandle, sessionHandle, text, edit) {
        const sessionInfo = sessions.get(sessionHandle);
        const pluginInfo = loadedPlugins.get(pluginHandle);
        if (!sessionInfo || !pluginInfo) return;

        pluginInfo.plugin.applyEdit(sessionInfo.session, text, edit);
        console.log(`[plugin-provider] pluginApplyEdit(${pluginHandle}, ${sessionHandle})`);
      },

      pluginParse(pluginHandle, sessionHandle) {
        const sessionInfo = sessions.get(sessionHandle);
        const pluginInfo = loadedPlugins.get(pluginHandle);
        if (!sessionInfo || !pluginInfo) {
          return { tag: 'err', val: { message: 'Invalid session or plugin' } };
        }

        try {
          const result = pluginInfo.plugin.parse(sessionInfo.session);
          console.log(`[plugin-provider] pluginParse(${pluginHandle}, ${sessionHandle}) -> ${result.spans.length} spans, ${result.injections.length} injections`);
          return result;
        } catch (e) {
          return { tag: 'err', val: { message: e.message } };
        }
      },

      pluginCancel(pluginHandle, sessionHandle) {
        const sessionInfo = sessions.get(sessionHandle);
        const pluginInfo = loadedPlugins.get(pluginHandle);
        if (!sessionInfo || !pluginInfo) return;

        pluginInfo.plugin.cancel(sessionInfo.session);
        console.log(`[plugin-provider] pluginCancel(${pluginHandle}, ${sessionHandle})`);
      },
    };

    // Host component
    let host = null;
    let currentDoc = null;

    async function initHost() {
      statusEl.textContent = 'Loading host component...';

      // First preload the plugins we'll need
      await loadPluginModule('html');
      await loadPluginModule('javascript');
      await loadPluginModule('rust');

      statusEl.textContent = 'Initializing host component...';

      // Load the host component
      const { instantiate } = await import('./host/arborium_host.js');

      const getCoreModule = async (path) => {
        const url = `./host/${path}`;
        const response = await fetch(url);
        const bytes = await response.arrayBuffer();
        return WebAssembly.compile(bytes);
      };

      // Build imports object
      const imports = {
        'arborium:host/plugin-provider@0.1.0': pluginProvider,
        'arborium:host/plugin-provider': pluginProvider,
        'arborium:host/types@0.1.0': {},
        'arborium:host/types': {},
        ...wasiStubs,
      };

      const component = await instantiate(getCoreModule, imports);
      host = component.host;

      statusEl.className = 'status ready';
      statusEl.textContent = 'Host component ready! Plugins loaded: rust, javascript, html';

      outputEl.textContent = `Host component initialized successfully.

Available operations:
- createDocument(language) -> document handle
- setText(doc, text)
- highlight(doc, maxDepth) -> spans with language info
- freeDocument(doc)

The host orchestrates plugins and resolves injections automatically.`;
    }

    function highlightCode(text, spans) {
      if (spans.length === 0) return escapeHtml(text);

      const parts = [];
      let pos = 0;

      for (const span of spans) {
        if (span.start > pos) {
          parts.push(escapeHtml(text.slice(pos, span.start)));
        }
        if (span.start >= pos) {
          const cssClass = span.capture.replace(/\./g, '-');
          parts.push(`<span class="${cssClass}">${escapeHtml(text.slice(span.start, span.end))}</span>`);
          pos = span.end;
        }
      }

      if (pos < text.length) {
        parts.push(escapeHtml(text.slice(pos)));
      }

      return parts.join('');
    }

    function escapeHtml(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    }

    async function doHighlight() {
      if (!host) {
        outputEl.textContent = 'Error: Host not initialized';
        return;
      }

      const lang = document.getElementById('language').value;
      const text = document.getElementById('input').value;

      outputEl.textContent = 'Highlighting...';
      highlightedEl.textContent = '';

      try {
        const start = performance.now();

        // Create a document through the host
        const doc = host.createDocument(lang);
        if (doc === undefined) {
          throw new Error(`Failed to create document for language: ${lang}`);
        }

        // Set text
        host.setText(doc, text);

        // Highlight with injection depth of 3
        const result = host.highlight(doc, 3);

        const elapsed = (performance.now() - start).toFixed(2);

        // Show results
        const byLang = {};
        for (const span of result.spans) {
          const key = span.language;
          if (!byLang[key]) byLang[key] = { count: 0, captures: {} };
          byLang[key].count++;
          byLang[key].captures[span.capture] = (byLang[key].captures[span.capture] || 0) + 1;
        }

        let output = `Highlighted in ${elapsed}ms\n`;
        output += `Document: ${doc}\n`;
        output += `Total spans: ${result.spans.length}\n\n`;
        output += `Spans by language:\n`;
        for (const [langName, info] of Object.entries(byLang)) {
          output += `\n  ${langName}: ${info.count} spans\n`;
          for (const [capture, count] of Object.entries(info.captures).sort()) {
            output += `    - ${capture}: ${count}\n`;
          }
        }

        outputEl.textContent = output;

        // Highlight code
        highlightedEl.innerHTML = highlightCode(text, result.spans);

        // Clean up
        host.freeDocument(doc);

      } catch (err) {
        outputEl.textContent = `Error: ${err.message}\n${err.stack}`;
        console.error(err);
      }
    }

    // Setup event handlers
    document.getElementById('parse').addEventListener('click', doHighlight);
    document.getElementById('language').addEventListener('change', (e) => {
      const examples = {
        rust: `fn main() {
    let message = "Hello, World!";
    println!("{}", message);

    for i in 0..10 {
        if i % 2 == 0 {
            println!("Even: {}", i);
        }
    }
}`,
        javascript: `function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const result = fibonacci(10);
console.log("Result:", result);

// Arrow function example
const double = (x) => x * 2;
`,
        html: `<!DOCTYPE html>
<html lang="en">
<head>
  <title>Hello World</title>
  <script>
    function greet(name) {
      const message = "Hello, " + name;
      console.log(message);
    }
  <\/script>
</head>
<body>
  <h1>Welcome</h1>
  <button onclick="greet('World')">Click</button>
</body>
</html>`,
      };
      document.getElementById('input').value = examples[e.target.value] || '';
    });

    // Set initial example
    document.getElementById('input').value = `<!DOCTYPE html>
<html lang="en">
<head>
  <title>Hello World</title>
  <script>
    function greet(name) {
      const message = "Hello, " + name;
      console.log(message);
    }
  <\/script>
</head>
<body>
  <h1>Welcome</h1>
  <button onclick="greet('World')">Click</button>
</body>
</html>`;

    // Initialize
    initHost().catch(err => {
      statusEl.className = 'status error';
      statusEl.textContent = `Failed to initialize: ${err.message}`;
      outputEl.textContent = `Initialization error: ${err.message}\n${err.stack}`;
      console.error(err);
    });
  </script>
</body>
</html>
