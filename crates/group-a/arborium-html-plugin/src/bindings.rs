// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod arborium {
    pub mod grammar {
        /// Core types shared between host and plugins.
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// A span of highlighted text with a capture name.
            #[derive(Clone)]
            pub struct Span {
                /// Byte offset where the span starts.
                pub start: u32,
                /// Byte offset where the span ends (exclusive).
                pub end: u32,
                /// The capture name (e.g., "keyword", "function", "string").
                pub capture: _rt::String,
            }
            impl ::core::fmt::Debug for Span {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Span")
                        .field("start", &self.start)
                        .field("end", &self.end)
                        .field("capture", &self.capture)
                        .finish()
                }
            }
            /// An injection point where another language should be parsed.
            #[derive(Clone)]
            pub struct Injection {
                /// Byte offset where the injection starts.
                pub start: u32,
                /// Byte offset where the injection ends (exclusive).
                pub end: u32,
                /// The language ID to inject (e.g., "javascript", "css").
                pub language: _rt::String,
                /// Whether to include the node children in the injection.
                pub include_children: bool,
            }
            impl ::core::fmt::Debug for Injection {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Injection")
                        .field("start", &self.start)
                        .field("end", &self.end)
                        .field("language", &self.language)
                        .field("include-children", &self.include_children)
                        .finish()
                }
            }
            /// Result of parsing text.
            #[derive(Clone)]
            pub struct ParseResult {
                /// Highlighted spans from this parse.
                pub spans: _rt::Vec<Span>,
                /// Injection points for other languages.
                pub injections: _rt::Vec<Injection>,
            }
            impl ::core::fmt::Debug for ParseResult {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ParseResult")
                        .field("spans", &self.spans)
                        .field("injections", &self.injections)
                        .finish()
                }
            }
            /// An edit to apply to the text (for incremental parsing).
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Edit {
                /// Byte offset where the edit starts.
                pub start_byte: u32,
                /// Byte offset of the old end (before edit).
                pub old_end_byte: u32,
                /// Byte offset of the new end (after edit).
                pub new_end_byte: u32,
                /// Row where the edit starts.
                pub start_row: u32,
                /// Column where the edit starts.
                pub start_col: u32,
                /// Old end row (before edit).
                pub old_end_row: u32,
                /// Old end column (before edit).
                pub old_end_col: u32,
                /// New end row (after edit).
                pub new_end_row: u32,
                /// New end column (after edit).
                pub new_end_col: u32,
            }
            impl ::core::fmt::Debug for Edit {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Edit")
                        .field("start-byte", &self.start_byte)
                        .field("old-end-byte", &self.old_end_byte)
                        .field("new-end-byte", &self.new_end_byte)
                        .field("start-row", &self.start_row)
                        .field("start-col", &self.start_col)
                        .field("old-end-row", &self.old_end_row)
                        .field("old-end-col", &self.old_end_col)
                        .field("new-end-row", &self.new_end_row)
                        .field("new-end-col", &self.new_end_col)
                        .finish()
                }
            }
            /// Error that can occur during parsing.
            #[derive(Clone)]
            pub struct ParseError {
                /// Error message.
                pub message: _rt::String,
            }
            impl ::core::fmt::Debug for ParseError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ParseError").field("message", &self.message).finish()
                }
            }
            impl ::core::fmt::Display for ParseError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for ParseError {}
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod arborium {
        pub mod grammar {
            /// The grammar plugin interface that each language implements.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod plugin {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type ParseResult = super::super::super::super::arborium::grammar::types::ParseResult;
                pub type Edit = super::super::super::super::arborium::grammar::types::Edit;
                pub type ParseError = super::super::super::super::arborium::grammar::types::ParseError;
                /// A handle to a parsing session.
                /// Sessions maintain parser state for incremental parsing.
                pub type Session = u32;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_language_id_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::language_id();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_language_id<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_injection_languages_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::injection_languages();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = result0;
                    let len3 = vec3.len();
                    let layout3 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec3.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result3 = if layout3.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout3);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec3.into_iter().enumerate() {
                        let base = result3
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                    }
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = result3;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_injection_languages<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base4 = l0;
                    let len4 = l1;
                    for i in 0..len4 {
                        let base = base4
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base4,
                        len4 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_session_cabi<T: Guest>() -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::create_session();
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_free_session_cabi<T: Guest>(arg0: i32) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::free_session(arg0 as u32);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_set_text_cabi<T: Guest>(
                    arg0: i32,
                    arg1: *mut u8,
                    arg2: usize,
                ) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    T::set_text(arg0 as u32, _rt::string_lift(bytes0));
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_apply_edit_cabi<T: Guest>(
                    arg0: i32,
                    arg1: *mut u8,
                    arg2: usize,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                ) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    T::apply_edit(
                        arg0 as u32,
                        _rt::string_lift(bytes0),
                        super::super::super::super::arborium::grammar::types::Edit {
                            start_byte: arg3 as u32,
                            old_end_byte: arg4 as u32,
                            new_end_byte: arg5 as u32,
                            start_row: arg6 as u32,
                            start_col: arg7 as u32,
                            old_end_row: arg8 as u32,
                            old_end_col: arg9 as u32,
                            new_end_row: arg10 as u32,
                            new_end_col: arg11 as u32,
                        },
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_parse_cabi<T: Guest>(arg0: i32) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::parse(arg0 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let super::super::super::super::arborium::grammar::types::ParseResult {
                                spans: spans2,
                                injections: injections2,
                            } = e;
                            let vec5 = spans2;
                            let len5 = vec5.len();
                            let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec5.len() * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result5 = if layout5.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout5);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec5.into_iter().enumerate() {
                                let base = result5
                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let super::super::super::super::arborium::grammar::types::Span {
                                        start: start3,
                                        end: end3,
                                        capture: capture3,
                                    } = e;
                                    *base.add(0).cast::<i32>() = _rt::as_i32(start3);
                                    *base.add(4).cast::<i32>() = _rt::as_i32(end3);
                                    let vec4 = (capture3.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                            }
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result5;
                            let vec8 = injections2;
                            let len8 = vec8.len();
                            let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec8.len() * (8 + 3 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result8 = if layout8.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout8);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec8.into_iter().enumerate() {
                                let base = result8
                                    .add(i * (8 + 3 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let super::super::super::super::arborium::grammar::types::Injection {
                                        start: start6,
                                        end: end6,
                                        language: language6,
                                        include_children: include_children6,
                                    } = e;
                                    *base.add(0).cast::<i32>() = _rt::as_i32(start6);
                                    *base.add(4).cast::<i32>() = _rt::as_i32(end6);
                                    let vec7 = (language6.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match include_children6 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                            }
                            *ptr1
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *ptr1
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::arborium::grammar::types::ParseError {
                                message: message9,
                            } = e;
                            let vec10 = (message9.into_bytes()).into_boxed_slice();
                            let ptr10 = vec10.as_ptr().cast::<u8>();
                            let len10 = vec10.len();
                            ::core::mem::forget(vec10);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len10;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr10.cast_mut();
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_parse<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base5 = l1;
                            let len5 = l2;
                            for i in 0..len5 {
                                let base = base5
                                    .add(i * (8 + 2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(8).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base5,
                                len5 * (8 + 2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l6 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l7 = *arg0
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base10 = l6;
                            let len10 = l7;
                            for i in 0..len10 {
                                let base = base10
                                    .add(i * (8 + 3 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l8 = *base.add(8).cast::<*mut u8>();
                                    let l9 = *base
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base10,
                                len10 * (8 + 3 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l11 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l12 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l11, l12, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_cancel_cabi<T: Guest>(arg0: i32) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::cancel(arg0 as u32);
                }
                pub trait Guest {
                    /// Get the language ID this plugin provides (e.g., "rust", "javascript").
                    fn language_id() -> _rt::String;
                    /// Get the language IDs that this grammar may inject.
                    /// Used by the host to know which plugins to preload.
                    fn injection_languages() -> _rt::Vec<_rt::String>;
                    /// Create a new parsing session.
                    fn create_session() -> Session;
                    /// Destroy a parsing session and free its resources.
                    fn free_session(session: Session) -> ();
                    /// Set the full text content for a session.
                    /// This replaces any previous content and resets the parse tree.
                    fn set_text(session: Session, text: _rt::String) -> ();
                    /// Apply an incremental edit to the session's text.
                    /// The session must have had set-text called previously.
                    fn apply_edit(session: Session, text: _rt::String, edit: Edit) -> ();
                    /// Parse the current text and return spans and injections.
                    /// If cancelled, returns an empty result.
                    fn parse(session: Session) -> Result<ParseResult, ParseError>;
                    /// Request cancellation of an in-progress parse.
                    /// The next call to parse() will return early.
                    fn cancel(session: Session) -> ();
                }
                #[doc(hidden)]
                macro_rules! __export_arborium_grammar_plugin_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "arborium:grammar/plugin@0.1.0#language-id")] unsafe extern "C"
                        fn export_language_id() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_language_id_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "cabi_post_arborium:grammar/plugin@0.1.0#language-id")] unsafe
                        extern "C" fn _post_return_language_id(arg0 : * mut u8,) { unsafe
                        { $($path_to_types)*:: __post_return_language_id::<$ty > (arg0) }
                        } #[unsafe (export_name =
                        "arborium:grammar/plugin@0.1.0#injection-languages")] unsafe
                        extern "C" fn export_injection_languages() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_injection_languages_cabi::<$ty > ()
                        } } #[unsafe (export_name =
                        "cabi_post_arborium:grammar/plugin@0.1.0#injection-languages")]
                        unsafe extern "C" fn _post_return_injection_languages(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_injection_languages::<$ty > (arg0) } } #[unsafe
                        (export_name = "arborium:grammar/plugin@0.1.0#create-session")]
                        unsafe extern "C" fn export_create_session() -> i32 { unsafe {
                        $($path_to_types)*:: _export_create_session_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "arborium:grammar/plugin@0.1.0#free-session")] unsafe extern "C"
                        fn export_free_session(arg0 : i32,) { unsafe {
                        $($path_to_types)*:: _export_free_session_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "arborium:grammar/plugin@0.1.0#set-text")] unsafe extern "C" fn
                        export_set_text(arg0 : i32, arg1 : * mut u8, arg2 : usize,) {
                        unsafe { $($path_to_types)*:: _export_set_text_cabi::<$ty >
                        (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "arborium:grammar/plugin@0.1.0#apply-edit")] unsafe extern "C" fn
                        export_apply_edit(arg0 : i32, arg1 : * mut u8, arg2 : usize, arg3
                        : i32, arg4 : i32, arg5 : i32, arg6 : i32, arg7 : i32, arg8 :
                        i32, arg9 : i32, arg10 : i32, arg11 : i32,) { unsafe {
                        $($path_to_types)*:: _export_apply_edit_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) } }
                        #[unsafe (export_name = "arborium:grammar/plugin@0.1.0#parse")]
                        unsafe extern "C" fn export_parse(arg0 : i32,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_parse_cabi::<$ty > (arg0) }
                        } #[unsafe (export_name =
                        "cabi_post_arborium:grammar/plugin@0.1.0#parse")] unsafe extern
                        "C" fn _post_return_parse(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_parse::<$ty > (arg0) } }
                        #[unsafe (export_name = "arborium:grammar/plugin@0.1.0#cancel")]
                        unsafe extern "C" fn export_cancel(arg0 : i32,) { unsafe {
                        $($path_to_types)*:: _export_cancel_cabi::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_arborium_grammar_plugin_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 5 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 5
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub use alloc_crate::alloc;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_grammar_plugin_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::arborium::grammar::plugin::__export_arborium_grammar_plugin_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::arborium::grammar::plugin);
    };
}
#[doc(inline)]
pub(crate) use __export_grammar_plugin_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:arborium:grammar@0.1.0:grammar-plugin:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 946] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xad\x06\x01A\x02\x01\
A\x09\x01B\x0c\x01r\x03\x05starty\x03endy\x07captures\x04\0\x04span\x03\0\0\x01r\
\x04\x05starty\x03endy\x08languages\x10include-children\x7f\x04\0\x09injection\x03\
\0\x02\x01p\x01\x01p\x03\x01r\x02\x05spans\x04\x0ainjections\x05\x04\0\x0cparse-\
result\x03\0\x06\x01r\x09\x0astart-bytey\x0cold-end-bytey\x0cnew-end-bytey\x09st\
art-rowy\x09start-coly\x0bold-end-rowy\x0bold-end-coly\x0bnew-end-rowy\x0bnew-en\
d-coly\x04\0\x04edit\x03\0\x08\x01r\x01\x07messages\x04\0\x0bparse-error\x03\0\x0a\
\x03\0\x1carborium:grammar/types@0.1.0\x05\0\x02\x03\0\0\x04span\x02\x03\0\0\x09\
injection\x02\x03\0\0\x0cparse-result\x02\x03\0\0\x04edit\x02\x03\0\0\x0bparse-e\
rror\x01B\x1d\x02\x03\x02\x01\x01\x04\0\x04span\x03\0\0\x02\x03\x02\x01\x02\x04\0\
\x09injection\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x0cparse-result\x03\0\x04\x02\x03\
\x02\x01\x04\x04\0\x04edit\x03\0\x06\x02\x03\x02\x01\x05\x04\0\x0bparse-error\x03\
\0\x08\x01y\x04\0\x07session\x03\0\x0a\x01@\0\0s\x04\0\x0blanguage-id\x01\x0c\x01\
ps\x01@\0\0\x0d\x04\0\x13injection-languages\x01\x0e\x01@\0\0\x0b\x04\0\x0ecreat\
e-session\x01\x0f\x01@\x01\x07session\x0b\x01\0\x04\0\x0cfree-session\x01\x10\x01\
@\x02\x07session\x0b\x04texts\x01\0\x04\0\x08set-text\x01\x11\x01@\x03\x07sessio\
n\x0b\x04texts\x04edit\x07\x01\0\x04\0\x0aapply-edit\x01\x12\x01j\x01\x05\x01\x09\
\x01@\x01\x07session\x0b\0\x13\x04\0\x05parse\x01\x14\x04\0\x06cancel\x01\x10\x04\
\0\x1darborium:grammar/plugin@0.1.0\x05\x06\x04\0%arborium:grammar/grammar-plugi\
n@0.1.0\x04\0\x0b\x14\x01\0\x0egrammar-plugin\x03\0\0\0G\x09producers\x01\x0cpro\
cessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
